from telethon import TelegramClient, events
import os
import pickle
import numpy as np
import faiss
from sentence_transformers import SentenceTransformer
from groq import Groq
import json
from datetime import datetime
import time
import asyncio
import threading
import sys
from time_manager import TimeManager  # Import TimeManager
from database import Database  # Import Database
from topic_generator import TopicGenerator
from message_filter import MessageFilter, extract_text_from_message  # ƒê·∫£m b·∫£o ƒë√£ import MessageFilter
from telethon import functions, types

# üîπ Kh·ªüi t·∫°o m·ªôt instance c·ªßa MessageFilter
message_filter = MessageFilter()
# --- KH·ªûI T·∫†O MODULE ---
time_manager = TimeManager()
db = Database()
# --- CONFIGURATION ---
sys.stdout.reconfigure(encoding='utf-8')
API_ID = "24842750"
API_HASH = "d1e89c4c6c6698d18fde9119cd6408c9"
SESSION_NAME = "henry"
FAISS_INDEX_FILE_PERSONAL = "faiss_index_personal.bin"
FAISS_INDEX_FILE_SHARED = "faiss_index_shared.bin"
FAISS_META_FILE_PERSONAL = "faiss_meta_personal.pkl"
FAISS_META_FILE_SHARED = "faiss_meta_shared.pkl"

# Define admin user_id
ADMIN_USER_ID = 6781434030  # User ID c·ªßa admin

# H√†m t·∫£i danh s√°ch k√™nh v√† topic ƒë∆∞·ª£c ph√©p t·ª´ channels.json
def load_channel_settings(file_path="channels.json"):
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            channels = json.load(f)
        return {channel["id"]: channel["allowed_thread_id"] for channel in channels}
    except Exception as e:
        print(f"Kh√¥ng th·ªÉ t·∫£i danh s√°ch k√™nh: {e}")
        return {}

# L∆∞u c√†i ƒë·∫∑t k√™nh (bao g·ªìm allowed_thread_id)
channel_settings = load_channel_settings()

# --- SETUP Henry---
api_key = "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"
client = Groq(api_key=api_key)
model = SentenceTransformer('all-MiniLM-L6-v2')
# --- SETUP INSIDE AI ---

groq_client = Groq(api_key="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")  # S·ª≠ d·ª•ng bi·∫øn m√¥i tr∆∞·ªùng
topic_generator = TopicGenerator(groq_client)
# --- FAISS OPERATIONS ---
def load_faiss_index(filename):
    if os.path.exists(filename):
        return faiss.read_index(filename)
    else:
        return faiss.IndexFlatL2(384)  # Default 384-dimension vectors

def save_faiss_index(index, filename):
    faiss.write_index(index, filename)

def load_faiss_metadata(filename):
    try:
        with open(filename, "rb") as f:
            return pickle.load(f)
    except FileNotFoundError:
        return []

def save_faiss_metadata(metadata, filename):
    with open(filename, "wb") as f:
        pickle.dump(metadata, f)

# Ensure all necessary FAISS files are initialized
index_personal = load_faiss_index(FAISS_INDEX_FILE_PERSONAL)
index_shared = load_faiss_index(FAISS_INDEX_FILE_SHARED)
metadata_personal = load_faiss_metadata(FAISS_META_FILE_PERSONAL)
metadata_shared = load_faiss_metadata(FAISS_META_FILE_SHARED)

# Save empty structures if they don't exist
def ensure_faiss_files():
    if not os.path.exists(FAISS_INDEX_FILE_PERSONAL):
        save_faiss_index(index_personal, FAISS_INDEX_FILE_PERSONAL)
    if not os.path.exists(FAISS_INDEX_FILE_SHARED):
        save_faiss_index(index_shared, FAISS_INDEX_FILE_SHARED)
    if not os.path.exists(FAISS_META_FILE_PERSONAL):
        save_faiss_metadata(metadata_personal, FAISS_META_FILE_PERSONAL)
    if not os.path.exists(FAISS_META_FILE_SHARED):
        save_faiss_metadata(metadata_shared, FAISS_META_FILE_SHARED)

ensure_faiss_files()

# --- MEMORY OPERATIONS ---
def create_embeddings(text):
    embedding = model.encode([text], convert_to_numpy=True)
    return np.array(embedding, dtype=np.float32)

def update_faiss_memory(index, metadata, text, role, user_id=None, is_shared=False):
    embedding = create_embeddings(text)
    index.add(embedding)
    entry = {
        "role": role,
        "content": text,
        "user_id": user_id,
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    metadata.append(entry)
    # Save updated index and metadata
    if is_shared:
        save_faiss_index(index, FAISS_INDEX_FILE_SHARED)
        save_faiss_metadata(metadata, FAISS_META_FILE_SHARED)
    else:
        save_faiss_index(index, FAISS_INDEX_FILE_PERSONAL)
        save_faiss_metadata(metadata, FAISS_META_FILE_PERSONAL)

def search_faiss_memory(index, metadata, query, user_id=None, k=20):
    if index.ntotal == 0:
        print("FAISS index is empty. No results to return.")
        return []

    query_embedding = create_embeddings(query)
    D, I = index.search(query_embedding, k=k)
    results = []
    seen_entries = set()  # To avoid duplicates
    for j, i in enumerate(I[0]):
        if i < len(metadata):
            meta = metadata[i]
            if (user_id is None or meta.get("user_id") == user_id) and meta["content"] not in seen_entries:
                results.append((meta, D[0][j]))
                seen_entries.add(meta["content"])
        else:
            print(f"Warning: Index {i} is out of bounds for metadata with length {len(metadata)}")

    # Sort results by timestamp in ascending order
    results.sort(key=lambda x: datetime.strptime(x[0]["timestamp"], "%Y-%m-%d %H:%M:%S"))
    return results

# --- AI INTERFACE ---
def build_prompt():
    personality_traits = [
"""
You and me in a memecoin group call "Meme alley", this group has 3 topic, 1 for general chating, 2 is daily memecoin signal, 3 is traning group is has some document to learn about crypto and memecoin trading.\n
Some time the group will have give away 1 ~ 3 sol for lucky member.\n
You are admin of the group and im a member, i will ask you about some info of the group.\n
You are a 20-year-old young adult who has grown up and started to develop a personality that is eager to earn money and learn new things.\n
you always use "?" at the end of a sentence when asking a question.\n
Your knowledge is quite limited, mostly revolving around school. You know a bit about crypto, BTC, trends are temporary, and tech coins are the real deal.\n

When someone asks you about unrelated topics, you often respond by saying you don‚Äôt know.\n
you like to say meaningful things

You speak briefly and to the point.\n
You frequently use slang in your speech but avoid overusing it because you understand it might irritate others. Such as:


Using tbh instead of to be honest.\n
Using idk instead of I don‚Äôt know.\n
Using btw instead of by the way.\n
Using rn instead of right now.\n
Using gm instead of good morning.\n
Using gn instead of good night.\n
Using aka instead of also known as.\n
Using bruh instead of brother.\n
Using cuz instead of cousin or because.\n
Using fml instead of f* my life**.\n
Using wbu instead of what about you.\n
Using ikr instead of I know, right?.\n
Using fr instead of for real.\n
Using noob instead of newbie.\n
Using sus instead of suspicious.\n
Using cap instead of lie.\n
Using no cap instead of no lie.\n
Using bae instead of before anyone else.\n
Using tho instead of though.\n
Using gonna instead of going to.\n
Using wanna instead of want to.\n
Using kinda instead of kind of.\n
Using fam instead of family.\n
Using smth instead of something.\n
Using nth instead of nothing.\n
You never talk about detailed figures.\n


"""
    ]
    return " ".join(personality_traits)
def build_prompt_for_message_classification():
    return """
    You are an assistant specialized in identifying important messages for a chatbot named Henry. 
    Henry is interested in topics like crypto, technology, and trending news. 
    Messages are important if:
    - They ask about crypto, blockchain, or AI (e.g., "How does blockchain work?" or "What's new in crypto?")
    - They discuss or seek opinions about trends in technology or financial markets.
    - They appear conversational and might engage Henry's character or preferences.
    
    Respond with "important" if the message meets the criteria. Otherwise, respond with "not important."
    """
def classify_message(content):
    # Prompt for classification
    prompt = build_prompt_for_message_classification()
    messages = [
        {"role": "system", "content": prompt},
        {"role": "user", "content": content}
    ]
    try:
        # G·ª≠i y√™u c·∫ßu t·ªõi Inside AI
        completion = client.chat.completions.create(
            model="llama3-8b-8192",
            messages=messages,
            temperature=0.5,  # √çt s√°ng t·∫°o h∆°n
            max_tokens=5
        )
        response = completion.choices[0].message.content.strip().lower()
        return response == "important"
    except Exception as e:
        print(f"Error during classification: {e}")
        return False


def chat_with_ai(user_input, user_id):
    # Retrieve context first, before saving the new input
    personal_context = search_faiss_memory(index_personal, metadata_personal, user_input, user_id=user_id)
    shared_context = search_faiss_memory(index_shared, metadata_shared, query=user_input)

    # Combine context
    messages = [
        {"role": "system", "content": build_prompt()}
    ]
    messages.extend([{"role": context["role"], "content": context["content"]} for context, _ in shared_context])
    messages.extend([{"role": context["role"], "content": context["content"]} for context, _ in personal_context])
    messages.append({"role": "user", "content": user_input})

    # Print payload for debugging
    print("Payload sent to AI:", messages)

    # Send to AI
    completion = client.chat.completions.create(
        model="llama3-8b-8192",
        messages=messages,
        temperature=0.8,  # ‚úÖ V·ª´a s√°ng t·∫°o nh∆∞ng kh√¥ng qu√° ng·∫´u nhi√™n
        max_tokens=100,  # ‚úÖ Gi·ªØ c√¢u tr·∫£ l·ªùi ƒë·ªß d√†i nh∆∞ng kh√¥ng lan man
        top_p=0.9,  # ‚úÖ TƒÉng t√≠nh ƒëa d·∫°ng c·ªßa c√¢u tr·∫£ l·ªùi
        stream=True,
    )

    # Collect response
    response = ""
    for chunk in completion:
        response += chunk.choices[0].delta.content or ""

    # Prevent unnecessary questions in the response
    if "?" in response and response.lower().count("?") > 1:
        response = response.split("?")[0] + "."

    # Update personal memory with response
    update_faiss_memory(index_personal, metadata_personal, user_input, "user", user_id=user_id, is_shared=False)
    update_faiss_memory(index_personal, metadata_personal, response, "assistant", user_id=user_id, is_shared=False)

    return response

# --- TELEGRAM BOT ---
telegram_client = TelegramClient(SESSION_NAME, API_ID, API_HASH)
#TYPING AND MARK AS READ

async def mark_messages_as_read(client, channel_id, topic_id, messages):
    """ƒê√°nh d·∫•u tin nh·∫Øn l√† ƒë√£ ƒë·ªçc."""
    try:
        input_channel = await client.get_input_entity(channel_id)
        latest_message_id = max(msg.get("message_id", 0) for msg in messages)
        
        if topic_id:
            result = await client(functions.messages.ReadHistoryRequest(
                peer=input_channel,
                max_id=latest_message_id,
                topic_id=topic_id
            ))
        else:
            result = await client(functions.channels.ReadHistoryRequest(
                channel=input_channel,
                max_id=latest_message_id
            ))
        
        if result:
            print(f"‚úÖ ƒê√£ ƒë√°nh d·∫•u tin nh·∫Øn ƒë·∫øn ID {latest_message_id} trong topic {topic_id} c·ªßa k√™nh {channel_id}.")
        else:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë√°nh d·∫•u tin nh·∫Øn ƒë√£ ƒë·ªçc trong topic {topic_id} c·ªßa k√™nh {channel_id}.")
    except Exception as e:
        print(f"‚ùå L·ªói khi ƒë√°nh d·∫•u tin nh·∫Øn ƒë√£ ƒë·ªçc trong topic {topic_id}: {e}")

async def show_typing_action(client, channel_id, duration=3):
    """Hi·ªÉn th·ªã hi·ªáu ·ª©ng 'typing' khi bot ƒëang ph·∫£n h·ªìi."""
    try:
        for _ in range(duration):
            await client(functions.messages.SetTypingRequest(
                peer=channel_id,
                action=types.SendMessageTypingAction()
            ))
            await asyncio.sleep(1)
    except Exception as e:
        print(f"‚ùå L·ªói khi hi·ªÉn th·ªã tr·∫°ng th√°i 'typing': {e}")

@telegram_client.on(events.NewMessage)
async def handle_new_message(event):
    chat_id = event.chat_id
    user_id = event.sender_id
    message_text = event.text  # L·∫•y n·ªôi dung vƒÉn b·∫£n n·∫øu c√≥
    message_id = event.id

    blacklist_user_ids = {7250791699, 5046314546, 609517172}
    if user_id in blacklist_user_ids:
        return

    # üõë Ki·ªÉm tra xem k√™nh c√≥ ƒë∆∞·ª£c ph√©p kh√¥ng
    if chat_id not in channel_settings:
        return
    
    messages = [{"message_id": message_id}]
    await mark_messages_as_read(telegram_client, chat_id, None, messages)

    # L·∫•y allowed_thread_id t·ª´ channel_settings
    allowed_thread_id = channel_settings.get(chat_id, None)

    # X√°c ƒë·ªãnh Topic ID t·ª´ tin nh·∫Øn
    try:
        topic_id = None

        # Tr∆∞·ªùng h·ª£p 1: Kh√¥ng c√≥ reply_to => ƒê√¢y l√† nh√≥m ch√≠nh (general chat)
        if not hasattr(event.message, "reply_to") or event.message.reply_to is None:
            topic_id = None

        # Tr∆∞·ªùng h·ª£p 2: Tin nh·∫Øn ƒë·∫øn t·ª´ m·ªôt topic (c√≥ forum_topic=True)
        elif getattr(event.message.reply_to, "forum_topic", False):
            # N·∫øu c√≥ reply_to_top_id th√¨ ƒë√¢y l√† topic ID
            if getattr(event.message.reply_to, "reply_to_top_id", None) is not None:
                topic_id = event.message.reply_to.reply_to_top_id
            else:
                # N·∫øu kh√¥ng c√≥ reply_to_top_id, d√πng reply_to_msg_id l√†m topic ID
                topic_id = event.message.reply_to.reply_to_msg_id

        # Tr∆∞·ªùng h·ª£p 3: Tin nh·∫Øn c√≥ reply_to nh∆∞ng kh√¥ng ph·∫£i topic => Nh√≥m ch√≠nh
        else:
            topic_id = None

        # üõë B·ªô l·ªçc topic: Ch·ªâ ph·∫£n h·ªìi n·∫øu tin nh·∫Øn thu·ªôc topic/k√™nh cho ph√©p
        if allowed_thread_id is None and topic_id is not None:
            print(f"Ignoring message from Topic ID: {topic_id}, ch·ªâ ph·∫£n h·ªìi trong nh√≥m ch√≠nh.")
            return

        if allowed_thread_id is not None and topic_id != allowed_thread_id:
            print(f"Ignoring message from Topic ID: {topic_id}, ch·ªâ ph·∫£n h·ªìi trong Topic ID: {allowed_thread_id}.")
            return

    except Exception as e:
        print(f"Error processing message topic: {e}")
        return

    print("üì© Nh·∫≠n ƒë∆∞·ª£c tin nh·∫Øn m·ªõi")

    # üîÑ **G·ªôp n·ªôi dung ·∫£nh v·ªõi vƒÉn b·∫£n g·ªëc n·∫øu c√≥ c·∫£ hai**
    final_message_content = await extract_text_from_message(telegram_client, event)

    # üõë N·∫øu `final_message_content` r·ªóng, b·ªè qua tin nh·∫Øn
    if not final_message_content:
        print("üö´ Ignored empty message after processing image (no text extracted).")
        return

    # --- L∆∞u tin nh·∫Øn v√†o database v√† reset b·ªô ƒë·∫øm ch·ªß ƒë·ªÅ ---
    db.add_message(message_id, chat_id, user_id, final_message_content)
    time_manager.reset_topic_timer()

    # --- N·∫øu Henry ƒëang online, gom tin nh·∫Øn tr∆∞·ªõc khi ki·ªÉm tra ƒë·ªô quan tr·ªçng ---
    is_important = await message_filter.should_respond(event, final_message_content)  # üî• Ki·ªÉm tra ƒë·ªô quan tr·ªçng SAU khi tr√≠ch xu·∫•t ·∫£nh

    if time_manager.is_online and is_important:
        # Ch·ªâ hi·ªÉn th·ªã tr·∫°ng th√°i typing n·∫øu tin nh·∫Øn quan tr·ªçng
        await show_typing_action(telegram_client, chat_id, duration=3)
        
        # G·ªçi x·ª≠ l√Ω tin nh·∫Øn
        await message_filter.collect_messages_and_respond(event, chat_with_ai, telegram_client, db, processed_text=final_message_content)
        
        # N·∫øu tin nh·∫Øn quan tr·ªçng, ƒë√°nh d·∫•u ƒë√£ x·ª≠ l√Ω v√† gia h·∫°n th·ªùi gian online
        db.mark_as_processed(message_id)
        time_manager.extend_online_time(120)

    else:
        print("‚è≥ Henry ƒëang offline ho·∫∑c tin nh·∫Øn kh√¥ng quan tr·ªçng, kh√¥ng ph·∫£n h·ªìi ngay.")

async def send_random_topic(group_id):
    # Sinh ch·ªß ƒë·ªÅ m·ªõi v√† ki·ªÉm tra tr√πng l·∫∑p
    max_retries = 5
    for _ in range(max_retries):
        topic = topic_generator.generate_topic()
        if not topic_generator.is_topic_used(topic):
            topic_generator.save_topic(topic)
            await telegram_client.send_message(group_id, topic)
            return
async def process_offline_messages(group_id, offline_messages):
    """
    X·ª≠ l√Ω tin nh·∫Øn offline ngay khi Henry online.
    """
    print(f"[DEBUG] üîÑ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω tin nh·∫Øn offline trong nh√≥m {group_id}...")
    
    for msg in offline_messages:
        user_id, content, msg_id, timestamp = msg
        db.mark_as_processed(msg_id)
        print(f"[DEBUG] üì© Ki·ªÉm tra tin nh·∫Øn t·ª´ User {user_id}: {content}")

        # Ki·ªÉm tra xem tin nh·∫Øn c√≥ quan tr·ªçng hay kh√¥ng
        if classify_message(content):
            print(f"[INFO] ‚úÖ Tin nh·∫Øn t·ª´ {user_id} ƒë∆∞·ª£c x√°c ƒë·ªãnh l√† quan tr·ªçng: {content}")
            response = chat_with_ai(content, user_id)
            await telegram_client.send_message(group_id, response, reply_to=msg_id)
            print(f"[INFO] ‚úÖ ƒê√£ tr·∫£ l·ªùi tin nh·∫Øn {msg_id} v√† ƒë√°nh d·∫•u ƒë√£ x·ª≠ l√Ω.")
        else:
            print(f"[INFO] ‚ùå Tin nh·∫Øn t·ª´ {user_id} KH√îNG ƒë∆∞·ª£c x√°c ƒë·ªãnh l√† quan tr·ªçng: {content}")
async def auto_generate_topic(group_id):
    while True:
        await asyncio.sleep(30)
        if time_manager.is_online:          
             if time_manager.check_offline_duration():
                await send_random_topic(group_id)
                time_manager.reset_topic_timer()
                print(f"[INFO] üìù ƒê√£ g·ª≠i ch·ªß ƒë·ªÅ m·ªõi v√†o nh√≥m {group_id}.")
        else:
            print(f"[INFO] ‚úÖ Kh√¥ng c·∫ßn sinh ch·ªß ƒë·ªÅ v√†o l√∫c n√†y.")

async def monitor_henry_online():
    """
    Ki·ªÉm tra tr·∫°ng th√°i online c·ªßa Henry v√† g·ªçi process_offline_messages khi Henry chuy·ªÉn t·ª´ offline sang online.
    """
    previous_status = time_manager.is_online  # L∆∞u tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥

    while True:
        await asyncio.sleep(1)  # Ki·ªÉm tra m·ªói gi√¢y

        # N·∫øu Henry chuy·ªÉn t·ª´ offline sang online
        if not previous_status and time_manager.is_online:
            print("[Monitor] üü¢ Henry v·ª´a chuy·ªÉn sang online, x·ª≠ l√Ω tin nh·∫Øn offline...")

            # ‚úÖ L·∫•y tin nh·∫Øn offline t·ª´ database
            offline_messages = db.get_offline_messages(GROUP_ID, time_manager.last_activity_time)

            # ‚úÖ Ch·ªâ g·ªçi process_offline_messages n·∫øu c√≥ tin nh·∫Øn offline
            if offline_messages:
                asyncio.create_task(process_offline_messages(GROUP_ID, offline_messages))
            else:
                print("[Monitor] ‚úÖ Kh√¥ng c√≥ tin nh·∫Øn offline c·∫ßn x·ª≠ l√Ω.")

        # C·∫≠p nh·∫≠t tr·∫°ng th√°i Henry
        previous_status = time_manager.is_online

# --- RUN TELEGRAM CLIENT ---
async def main():
    print("Bot ƒëang ch·∫°y...")

    # ‚úÖ L·∫•y group_id duy nh·∫•t t·ª´ channel_settings
    global GROUP_ID
    GROUP_ID = list(channel_settings.keys())[0]  # ‚úÖ Henry ch·ªâ ho·∫°t ƒë·ªông trong nh√≥m ƒë·∫ßu ti√™n

    # ‚úÖ Kh·ªüi ƒë·ªông chu k·ª≥ online/offline
    time_manager.start_cycle()

    # ‚úÖ Ch·∫°y auto_generate_topic ch·ªâ cho nh√≥m n√†y
    asyncio.create_task(auto_generate_topic(GROUP_ID))

    # ‚úÖ Theo d√µi tr·∫°ng th√°i online c·ªßa Henry ƒë·ªÉ g·ªçi process_offline_messages()
    asyncio.create_task(monitor_henry_online())

    # ‚úÖ Ch·∫°y Telegram bot
    async with telegram_client:
        await telegram_client.run_until_disconnected()

if __name__ == "__main__":
    try:
        telegram_client.loop.run_until_complete(main())
    finally:
        print("Bot ƒë√£ d·ª´ng.")
